# Day3 - 데이터 타입, 실행 컨텍스트   

- 자바스크립트의 타입
    - 자바스크립트의 변수는 어떤 특정 타입과 연결되지 않으며, 모든 타입의 값으로 할당(및 재할당) 가능하다.
- 변수와 식별자
    - 변수 : 데이터가 담길 수 있는 공간 또는 그릇
        - 변경 가능한 데이터
    - 식별자 : 변수명
        - 변수가 되는 어떤 데이터를 식별하는 데 사용하는 이름
- 데이터타입(기본형과 참조형)
    - 기본형 : number, string, boolean, null, undefined, symbol
    - 참조형 : array, function, RegExp, Set/SeakSet, Map/WeakMap
        - 가변적인 데이터 그룹
        - 여유롭게 공간을 미리 확보를 해야한다.
    
    각 데이터가 메모리상에서 저장되는 형태를 통해서 알아보기
    
    - 스택 메모리 : 변수, 기본형 데이터, 정적 할당
    - 힙 메모리 : 참조형 데이터, 동적 할당
    
    작은 용량의 값일 땐 상관없는데 큰 용량의 데이터를 사용하게 되면 하나하나 값을 비교해야하기 때문에 비효율적이라서 메모리에 저장해두고 주솟값을 이용해서 참조하는 게 좋다.
    
    - **값을 직접 저장** : 데이터 할다이세는 빠름, 비교에 비용이 많이 듦, 메모리 낭비가 심함
    - **값의 주소를 저장** : 데이터 할당시에는 느림, 비교에 비용이 들지 않음, 메모리 낭비 최소화
    - **불변값** : 같은 값이 오직 하나만 존재 → 기본형 데이터
    - 기본형 데이터의 복사
    - 참조형 데이터의 복사
    
- 실행 컨텍스트
    
    **Execution Context : 함수를 실행하는 데에 필요한 배경이 되는 조건 / 환경**
    
    어떤 코드를 봤을 때 그 코드가 이 자리에서 어떤 역할을 수행하는 지를이해하기 위해서는 그 코드에 영향을 주는 주변 코드나 변수들을 파악해야한다. 그렇게 영향을 주는 환경을 일컬어서 context라고 한다.
    
     - Variable Environment
    
     - Lexical Environment
    
     - environmentRecord : 현재문맥의 식별자(hoisting)
    
     - outerEnvironmentReference : 외부 식별자(scope chain)
    
     - this
    
    **동일한 조건 / 환경을 지니는 코드 뭉치 : 전역공간, 함수,** eval**, module**
    
     ****- 전역공간, module : 자바스크립트 코드가 실행되는 순간에 바로 전역 컨텍스트가 생성되고 전체 코드가 끝날 때 전역 컨텍스트가 종료되므로 이를 하나의 거대한 함수공간으로 봐도 무방하다.
    
     
    
    ```jsx
    var a = 1;
    function outer() {
    	console.log(a);
    
    	function inner() {
    		console.log(a);
    		var a = 3;
    	}
    	inner();
    	
    	console.log(a);
    }
    outer();
    console.log(a);	
    
    // 1
    // undefined
    // 1
    // 1
    ```
    
    - call stack : 코드 실행에 관여하는 스택
        - 현재 어떤 함수가 동작중인지
        - 다음에 어떤 함수가 호출될 예정인지
        - 등을 제어하는 자료구조
    
    - Lexical Environment : 어휘적 / 사전적 환경
        
        <aside>
        💡 실행 컨텍스트A 환경 사전 
        - 내부 식별자 a : 현재 값은 undefined이다.
        - 내부 식별자 b : 현재 값은 20이다.
        - 외부 정보 : D를 참조한다.
        
        </aside>
        
        실행 컨텍스트가 실행되고 최초로 하는 일 → 호이스팅
        
        - **호이스팅** : 현재 문맥의 식별자 정보를 수집한다.
        - **스코프** : 외부로는 나갈 수 있는데 안쪽으로는 들어갈 수 없다.
        - **스코프 체인** : inner에서 “어떤 변수를 찾아”라고 명령을 하면 일단 inner에서 찾고 없으면 outerEnvironmentReference를 타고 outer에서 변수를 찾는다. 또 없으면 전역 컨텍스트에 있는 environmentRecord를 찾는다.
            
            **→ 가장 가까운 자기 자신부터 점점 멀리 있는 스코프로 찾아 나가는 것**
            
- 웹 브라우저 동작원리 (Stack, Queue, event loop)
    - 웹브라우저 동작원리를 왜 알아야하는가?
        
        우리가 코드를 작성하면 브라우저가 실행해준다.
        
    - 다른 언어와의 차이점
        - 다른 언어는 위에서부터 한줄씩 실행시킨다
        
        ```jsx
        console.log(1+1); // 1
        setTimeout(function() {console.log(2+2)}, 1000); //3
        console.log(3+3); // 2
        ```
        
        → 자바스크립트는 한줄씩 실행시키지만 Ajax요청코드, 이벤트리스너, setTimeout(0초여도 보냄) 등 오래걸리는 코드들은 대기실로 보낸다.
        
        → 대기가 끝난 코드는 Queue에 줄세워 보관
        
        → Stack이 비워지면 Stack에 올려보낸다.
        
        - 만약 어려운 연산을 작성하게 되면 스택에서 작동되는 시간이 오래걸려서 스택에 비어있지 않은 상태에서 이벤트리스너가 발생하면 반응이 없다. 응답 대기중 창이 뜬다.
        - Queue에도 시간이 오래걸리는 코드나 복잡하게 코드를 넣게 되면 x
        - 자바스크립트는 동기적으로 처리된다.(한 줄에 한 줄씩)
        - 가끔 비동기적 처리도 가능하다.(setTimeout, eventListener, Ajax)
- 스코프(scope)
    
    스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바스크립트는 이 규칙대로 식별자를 찾는다.
    
    전역에 선언된 변수는 어디에든 참조할 수 있다. 하지만 함수 내에서 선언된 변수는 함수 외부에서는 참조할 수 없다. 이러한 규칙을 스코프라고 한다.
    
- 모든 코드는 실행 순서가 있고, 실행 컨텍스트는 그것과 관련된 것이다.
    - 실행 컨텍스트(Execution Context)
        
        <aside>
        💡 자바스크립트 코드가 실행되고 연산되는 범위를 나타내는 추상적인 개념
        
        </aside>
        
        우리가 코드를 작성하고 실행한다면 실행 컨텍스트 내부에서 실행되고 있는 것이다. 코드들이 실행되기 위한 환경이자 하나의 박스이자 컨테이너라 볼 수 있다. 
        
    - 코드의 실행 순서를 관리하는 **콜스택**
        
        <aside>
        💡 코드의 실행에 필요한 환경 정보를 “컨텍스트”라고 이름 지어서 객체로 만들어 두고 실행 순서에 따라 콜스택에 쌓았다가, 가장 이에 쌓여있는 컨텍스트와 관련 있는 코드를 실행하는 순서로 이루어진다.
        
        </aside>
        
    
    - 실행 컨텍스트는 어떻게 구성되어 있는가?
        
        <aside>
        💡 실행 컨텍스트는 생성단계와 실행단계로 이루어져 있다. 그리고 두 가지로 이루어져 있는데, 해당 스코프 안에 어떤 변수 등이 있는지 적혀있는 객체와 지금 스코프(함수) 바로 바깥이 어디인지 알려주는 참조로 이해하면 된다.
        
        </aside>
        
- 기본형, 참조형

***
# Javascript Algorithm

### Math.ceil(n) - 올림

```jsx
// 1.소수점이하
const ceil_1 = Math.ceil(1.222 * 10) / 10; // 1.3
const ceil_2 = Math.ceil(1.222 * 100) / 100; // 1.23

// 2. 10단위, 100단위
const ceil_3 = Math.ceil(1222 / 10) * 10; // 1230
const ceil_4 = Math.ceil(1222 / 100) * 100; // 1300
```

### Math.floor(n) - 내림

### Math.round(n) - 반올림

### ****소수점 숫자 정밀도 문제****

- 부동 소수점 오차

javascript에서 실수를 처리하는 방식 때문에 약간의 오차가 발생한다.

```jsx
const n = 1.005 * 100; // 100.499999999999
const round = Math.round(1.005 * 100) / 100; // 1
```

- 부동 소수점 오차 보정

```jsx
const n1 = (1.005 + Number.EPSILON) * 100; 
const round1 = Math.round((1.005 + Number.EPSILON) * 100) / 100; // 1.01
```

→ n1 값은 100.5가 아니다. 오차가 많이 줄어들게 되었을 뿐이다.

### toPrecision()

```jsx
const n = 1.123.toPrecision(2); // 1.2
```